# def solution(s):
#     u = ""
#     for i in range(len(s)):
#         if s[i].islower():
#             u += s[i]
#         else:
#             u += " "
#             u += s[i]
#     return u
#
# s = input().strip()
# print(solution(s))

# ===============================================================================================================================================================
# """
# Вы, наверное, знаете систему «лайков» из Facebook и других страниц.
# Люди могут «лайкать» сообщения в блогах, изображения или другие элементы.
#  Мы хотим создать текст, который должен отображаться рядом с таким элементом.
#
# Реализуйте функцию, которая принимает массив, содержащий имена людей,
# которым понравился элемент. Он должен возвращать отображаемый текст, как показано в примерах:
#
# []                                -->  "no one likes this"
# ["Peter"]                         -->  "Peter likes this"
# ["Jacob", "Alex"]                 -->  "Jacob and Alex like this"
# ["Max", "John", "Mark"]           -->  "Max, John and Mark like this"
# ["Alex", "Jacob", "Mark", "Max"]  -->  "Alex, Jacob and 2 others like this"
# """
#

# def likes(names):
#     end_line = 'likes this'
#     amount_of_elements = len(names)
#     if amount_of_elements < 2:
#         if amount_of_elements == 0:
#             return f'no one {end_line}'
#         elif amount_of_elements == 1:
#             return f'{names[0]} {end_line}'
#     else:
#         end_line = "like this"
#         if amount_of_elements == 2:
#             return f'{names[0]} and {names[1]} {end_line}'
#         elif amount_of_elements == 3:
#             return f'{", ".join(names[:2])} and {names[2]} {end_line}'
#         else:
#             return f'{", ".join(names[:2])} and {amount_of_elements-2} others {end_line}'
#

# ===============================================================================================================================================================
# """
# Панграмма — это предложение, в котором каждая буква алфавита встречается хотя бы по одному разу.
# Например, предложение «Быстрая коричневая лиса перепрыгивает через ленивую собаку» является панграммой,
#  потому что в нем хотя бы один раз используются буквы AZ (регистр значения не имеет).
#
# Учитывая строку, определите, является ли она панграммой. Возвращает True, если это так,
# False, если нет. Не обращайте внимания на цифры и знаки препинания."""
#
#
# def is_pangram(s):
#     special_meanings = set(s.lower())
#     asccii_char = 96
#     while True:
#         asccii_char += 1
#         if chr(asccii_char) in special_meanings:
#             continue
#         else:
#             break
#     if asccii_char >= 122:
#         return True
#     else:
#         return False
#
#
# print(is_pangram("Aacdefghijklmnopqrstuvwxyz"))

# ===============================================================================================================================================================
# """
# В маленьком городке население p0 = 1000на начало года.
# Население регулярно увеличивается на 2 percent1 год, и, кроме того , 50
# каждый год в город приезжают новые жители. Сколько лет нужно городу,
# чтобы его население было больше или равно количеству p = 1200жителей?
#
# At the end of the first year there will be:
# 1000 + 1000 * 0.02 + 50 => 1070 inhabitants
#
# At the end of the 2nd year there will be:
# 1070 + 1070 * 0.02 + 50 => 1141 inhabitants (** number of inhabitants is an integer **)
#
# At the end of the 3rd year there will be:
# 1141 + 1141 * 0.02 + 50 => 1213
#
# It will need 3 entire years.
# Более общие параметры:
#
# p0, percent, aug (inhabitants coming or leaving each year), p (population to equal or surpass)
#
# функция nb_yearдолжна возвращать nколичество полных лет, необходимых для получения населения, большего или равного p.
#
# aug — целое число, процент — положительное или нулевое плавающее число, p0 и p — положительные целые числа (> 0)
#
# Examples:
# nb_year(1500, 5, 100, 5000) -> 15
# nb_year(1500000, 2.5, 10000, 2000000) -> 10
# Примечание:
# Не забудьте преобразовать параметр процента в процент в теле вашей функции:
# если параметр процента равен 2, вы должны преобразовать его в 0,02.
# """
#
#
# def nb_year(p0, percent, aug, p):
#     starting_strength = int(p0) + (int(p0) * percent / 100) + int(aug)
#     counter = 1
#     while 0 < starting_strength < p:
#         starting_strength = int(starting_strength) + (int(starting_strength) * percent / 100) + int(aug)
#         counter += 1
#     return int(counter)
#
#
# print(nb_year(1500, 5, 100, 5000))

# ===============================================================================================================================================================
# """
# Если мы перечислим все натуральные числа до 10, кратные 3 или 5, мы получим 3, 5, 6 и 9. Сумма этих кратных равна 23.
#
# Завершите решение так, чтобы оно возвращало сумму всех чисел, кратных 3 или 5 , меньше переданного числа.
# Кроме того, если число отрицательное, верните 0 (для языков, в которых они есть).
#
# Примечание. Если число кратно и 3, и 5, считайте его только один раз .
#
# Предоставлено projecteuler.net ( проблема 1 )
# """
#
#
# def solution(number):
#     sum_nums = 0
#     if number <=0:
#         return 0
#     elif (number > 0) and (sum_nums < number):
#         for i in range(0, number):
#             if (i % 3 == 0) or i % 5 == 0:
#                 sum_nums += i
#         return sum_nums


# ===============================================================================================================================================================


# """
# Маркетинговая команда тратит слишком много времени на ввод хэштегов.
# Давайте поможем им с нашим генератором хэштегов!
#
# Вот сделка:
#
# Он должен начинаться с хэштега ( #).
# Во всех словах первая буква должна быть заглавной.
# Если окончательный результат длиннее 140 символов, он должен вернуть false.
# Если ввод или результат представляет собой пустую строку, она должна возвращаться false.
# Примеры
# " Hello there thanks for trying my Kata"  =>  "#HelloThereThanksForTryingMyKata"
# "    Hello     World   "                  =>  "#HelloWorld"
# ""                                        =>  false
# """
#
# def generate_hashtag(s):
#     if (len(s) <= 140) and s:
#         return f'#{"".join(s.strip().title().replace(" ", ""))}'
#     return False
#
# ===============================================================================================================================================================
# """
# Пит любит печь торты. У него есть рецепты и ингредиенты. К сожалению, он не силен в математике.
# Поможешь ему узнать, сколько тортов он сможет испечь, учитывая его рецепты?
#
# Напишите функцию cakes(), которая принимает рецепт (объект) и доступные ингредиенты (тоже объект) и
# возвращает максимальное количество пирожных, которые Пит может испечь (целое число).
# Для простоты нет единиц измерения количества (например, 1 фунт муки или 200 г сахара — это просто 1 или 200).
# Ингредиенты, отсутствующие в объектах, можно считать равными 0.
#
# Примеры:
#
# # must return 2
# cakes({flour: 500, sugar: 200, eggs: 1}, {flour: 1200, sugar: 1200, eggs: 5, milk: 200})
#
# # must return 0
# cakes({apples: 3, flour: 300, sugar: 150, milk: 100, oil: 100}, {sugar: 500, flour: 2000, milk: 2000})
#
# """


# def cakes(recipe, available):
#     l = []  # список сбора количество каждого ингрентеента
#     if len(recipe.keys()) > len(available.keys()):  # если в рецепте ключей(ингридиентов) больше чем в дано вернуть 0
#         return 0
#     elif len(recipe.keys()) < len(available.keys()):  # если в рецепте ключей(инг) меньше то добавить их в рец с знач. 0
#         for k in available.keys():  # проверка каждого ключа
#             if 0 in l:
#                 return 0
#             elif k in recipe.keys():  # если ключ в словаре то считаем сколько мы можем по данному ингриденту приготовить
#                 l.append(available.get(k) // recipe.get(k))
#                 continue
#             else:  # если ключа нет в рецепте а в дано он есть то в целом всеранво что будет(получиться по факту бред)
#                 # просто добавляем большое значение сказано что нужно добавить 0 к недостающему ключу,
#                 # но мы не сможем поделить на 0, поэтому добавим 1
#                 l.append(available.get(k) // 1)
#
#     elif recipe.keys() == available.keys():
#         for k in recipe.keys():
#             l.append(available.get(k) // recipe.get(k))
#     return min(l)

# def cakes(recipe, available):
#     l = []
#     recipe_ingr = {} | recipe  # Создаем копии
#     available_ing = {} | available  # Создаем копии для работы
#     if len(recipe_ingr.keys()) < len(available_ing.keys()):  # Проверяем на разницу ключей и дополняем словари
#         for k in available_ing:
#             if k not in recipe_ingr:
#                 recipe_ingr |= {k: 0}
#             continue
#     elif len(recipe_ingr.keys()) > len(available_ing.keys()):
#         for k in recipe_ingr:
#             if k not in available_ing:
#                 available_ing |= {k: 0}
#             continue
#
#     # Основной блок функции (вычисления)
#     for k in recipe_ingr:
#         a = int(available_ing.get(k))
#         r = int(recipe_ingr.get(k))
#         # print(f"{k}: {r}\t|\t{k}: {a}\n".center(30))
#         if (a == 0) and (r > 0):
#             return 0
#         elif (int(r) == 0) and (int(a) > 0):
#             l.append(a)
#         else:
#             l.append(int(a // r))
#
#     return min(l)
#
#
# #
# recipe = {"flour": 500, "sugar": 200, "eggs": 1}
# available = {"flour": 1200, "sugar": 1200, "eggs": 5, "milk": 200}
# print(cakes(recipe, available))
# recipe = {"apples": 3, "flour": 300, "sugar": 150, "milk": 100, "oil": 100}
# available = {"sugar": 500, "flour": 2000, "milk": 2000}
# print(cakes(recipe, available))

# ===============================================================================================================================================================
"""

"""

# ===============================================================================================================================================================
"""

"""

# ===============================================================================================================================================================
"""

"""

# ===============================================================================================================================================================
"""

"""

# ===============================================================================================================================================================
"""

"""

# ===============================================================================================================================================================
"""

"""

# ===============================================================================================================================================================
"""

"""

# ===============================================================================================================================================================
"""

"""
